#!/bin/bash

# create a restore of a backup in -b <dir>

prefix=@prefix@
datarootdir=@datarootdir@
exec_prefix=@exec_prefix@
datadir=@datadir@/rdup

# common stuff
source $datadir/shared.sh

usage() {
	cat << HELP
"$PROGNAME SOURCE [SOURCE ...] DIR

This is a wrapper around rdup and rdup-snap -R
DIR    - directory to restore to
SOURCE - source to restore from:
      ssh://user@host/directory (note: no colon after the hostname
      file:///directory (note: 3 slashes)
      /directory
      directory

OPTIONS:
    -k KEYFILE decrypt all files, using mcrypt (rdup-crypt -d)
    -g	       decrypt all files, using gpg (rdup-gpg -d)
    -z         decompress all files, using gzip (rdup-gzip -d)
    -v         echo the files processed to stderr
    -x         pass -x to rdup
    -h         this help
    -V         print version
HELP
}

PROGNAME=$0
BACKUPDIR=""
c=""
pipe=""
ssh=""
zip=false
enc=false
dump=true
while getopts ":ak:vgzxhV" o; do
        case $o in
                k) KEYFILE=$OPTARG
                if [[ -z "$OPTARG" ]]; then
                        _echo2 "-k needs an argument"
                        exit 1
                fi
                if [[ ! -r "$OPTARG" ]]; then
                        _echo2 "Cannot read keyfile \`$OPTARG': failed"
                        exit 1
                fi
                pipe="$pipe | @bindir@/rdup-crypt -d $OPTARG"
                c="-c"
		if $zip; then
			_echo2 "Select decryption first, then decompression"
			exit 1
		fi
		enc=true
                ;;
		g)
		if $enc; then
			_echo2 "Encryption already set"
			exit 1
		fi
                pipe="$pipe | @bindir@/rdup-gpg -d"
		c="-c"
		enc=true
		;;
                D)
                dump=true;;
                S)
                dump=false;;
                z) pipe="$pipe | @bindir@/rdup-gzip -d"
                c="-c"
		zip=true
                ;;
                a) ;;
                v) OPT="$OPT -v";;
                x) x="-x";;
                V) version && exit;;
                h) usage && exit;;
                \?) _echo2 "Invalid option: $OPTARG"; exit 1;;
        esac
done
shift $((OPTIND - 1))
if [[ $# -eq 0 ]]; then
	usage
        exit
fi

# rdup [options] sources destination
#dest="ssh://elektron.atoom.net/directory"
#dest="ssh://elektron.atoom.net/directory/var/"
#dest="file:///var/backup"
#dest="/var/backup"
#dest="ssh://miekg@elektron.atoom.net/directory"

# look through the source dirs
# either one ssh:// or all local is allowed
i=1; last=$#; SOURCE=
ssh_seen=false
while [[ $i -lt $last ]]; do
	src=$1
	if [[ ${src:0:6} == "ssh://" ]]; then
		if $ssh_seen; then
			_echo2 "Sorry; there can only be one remote source"
			exit 1
		fi

		rest=${src/ssh:\/\//}
		u=`echo $rest | cut -s -f1 -d@`
		rest=${rest/$u@/}
		h=`echo $rest | cut -s -f1 -d/`

		c="-c"
		l=""     # enable race checking
		ssh_seen=true
		if [[ -z $u ]]; then
			ssh=" ssh -x $h"
		else
			ssh=" ssh -x $u@$h"
		fi
		SOURCE=${rest/$h/}
		shift; ((i=$i+1))
		continue
	fi
	if [[ ${src:0:7} == "file://" ]]; then
		if $ssh_seen; then
			_echo2 "Sorry; a remote source has been specified"
			exit 1
		fi
		rest=${src/file:\/\//}
		SOURCE="$SOURCE $rest"
		shift; ((i=$i+1))
		continue
	fi

	if $ssh_seen; then
	    _echo2 "Sorry; a remote source has been specified"
	    exit 1
	fi
	SOURCE="$SOURCE $src"
	shift; ((i=$i+1))
done
dest=$1
if [[ ${dest:0:6} == "ssh://" ]]; then
	_echo2 "Destination cannot be a remote host"
	exit 1
fi

# add pwd if the path was relative
if [[ ${1:0:1} == "/" ]]; then
        dest="$1"
else
        dest="`pwd`/$1"
fi

# create the command line
if [[ -z $ssh ]]; then
	pipe="$pipe | @bindir@/rdup-snap -b $dest -R $c $OPT"
	cmd="@bindir@/rdup $x $l $c /dev/null $SOURCE $pipe"
else
	# needs to be found with PATH
	pipe="$pipe | rdup-snap -b $dest -R $c $OPT"
	cmd="$ssh @bindir@/rdup $x $l $c /dev/null $SOURCE $pipe"
fi
#cmd="@bindir@/rdup $x $l $c /dev/null $SOURCE $pipe"

# execute the backup command
# _echo2 "Executing: ${cmd}"
eval ${cmd}
