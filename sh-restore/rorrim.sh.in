#!/bin/bash
#
# Copyright (c) 2005, 2006 Miek Gieben
# See LICENSE for the license
#
# This script implement restoring a backup
# it is the opposite of mirror.sh

S_ISDIR=16384   # octal: 040000 (This seems to be portable...)
S_ISLNK=40960   # octal: 0120000
S_MMASK=4095    # octal: 00007777, mask to get permission
remote=0
verbose=0
dirstrip=0
idir=0; ireg=0; ilnk=0
ftsize=0
ts=`date +%s`
restoredir=""
newpath=""
PROGNAME=$0

_echo() {
        echo "** $PROGNAME: $1"
}

_echo2() {
        echo "** $PROGNAME: $1" >&2
}

cleanup() {
        _echo2 "$PROGNAME: Signal received while processing \`$path', exiting"
        exit 1
}
# trap at least these
trap cleanup SIGINT SIGPIPE

usage() {
        echo "$PROGNAME [OPTIONS] DIRECTORY"
        echo
        echo Restore the files in the filelist from rdup to DIRECTORY
        echo DIRECTORY is created when it does not exist
        echo
        echo OPTIONS
        echo " -c      process the file content also (rdup -c), for remote backups"
        echo " -v      echo the files processed to stderr"
        echo " -p NUM  strip \`NUM' leading components from file names"
        echo " -h      this help"
        echo " -V      print version"
}

sanity_check() {
        if [[ ! "$mode" =~ "[0-9]+" ]]; then
                _echo2 "mode must be numeric"
                exit 1
        fi
        if [[ ! "$psize" =~ "[0-9]+" ]]; then
                _echo2 "psize must be numeric"
                exit 1
        fi
        if [[ ! "$fsize" =~ "[0-9]+" ]]; then
                _echo2 "fsize must be numeric"
                exit 1
        fi
        if [[ ! "$uid" =~ "[0-9]+" || ! "$gid" =~ "[0-9]+" ]]; then
                _echo2 "uid or gid must be numeric"
                exit 1
        fi
}

version() {
        echo "$PROGNAME: @PACKAGE_VERSION@ (rdup-utils)"
}

# strip of $1 leading path components
_strip() {
        i=$1
        shift
        p="$@"
        while [[ $i -ge 1 ]]; do
                if [[ "$p" =~ "([^/]+)(.*)" ]]; then
                        p="${BASH_REMATCH[2]}"
                fi
                i=$(($i-1))
        done
        echo $p
}

# return a pathname without the suffix: +DD.MM:HH
sanitize() {
        name=""
        if [[ "$1" =~ "(.+)\\+(..)\\.(..):(..)$" ]]; then
                name=${BASH_REMATCH[1]}
        else
                name=$1
        fi
        echo $name
}

_restore() {
        declare -a path # catch spacing in the path
        while read -r mode uid gid psize fsize
        do
                dump=${mode:0:1}                # to add or remove
                mode=${mode:1}                  # st_mode bits
                path=$(head -c $psize)          # gets the path

                sanity_check

                bits=$(($mode & $S_MMASK))      # permission bits
                bits=`printf "%o" $bits`        # and back to octal again
                typ=0

                if [[ $(($mode & $S_ISDIR)) == $S_ISDIR ]]; then
                        typ=1;
                fi
                if [[ $(($mode & $S_ISLNK)) == $S_ISLNK ]]; then
                        typ=2;
                fi
                
                [[ $verbose -eq 1 ]] && echo $path >&2

                # create the new filename
                newpath=$(sanitize "$path")
                
                # -p NUM argument
                newpath=$(_strip $dirstrip "$newpath")

                if [[ -z "$newpath" ]]; then
                        # discard, because the whole name was stripped
                        if [[ $remote -eq 1 ]]; then
                                if [[ $fsize -eq 0 ]]; then
                                        continue
                                else
                                        head -c $fsize > /dev/null
                                fi
                        else
                                continue
                        fi
                fi

                # it can be that the file without extension does not 
                # exist in the backup directory because it is removed
                # from disk. If this is the case, skip it
                #
                if [[ ! -e $path ]]; then
                        continue
                fi

                if [[ $dump == "+" ]]; then
                        # add
                        case $typ in
                                0)      # REG
                                if [[ $remote -eq 1 ]]; then
                                        if [[ $fsize -ne 0 ]]; then
                                                head -c $fsize > "$restoredir/$newpath"
                                        fi
                                else
                                        cp -RP "$path" "$restoredir/$newpath"
                                fi
                                chown $uid:$gid "$restoredir/$newpath" 2>/dev/null
                                chmod $bits "$restoredir/$newpath"
                                ftsize=$(($ftsize + $fsize))
                                ireg=$(($ireg + 1))
                                ;;
                                1)      # DIR
                                [[ ! -d "$restoredir/$newpath" ]] && mkdir -p "$restoredir/$newpath" 
                                chown $uid:$gid "$restoredir/$newpath" 2>/dev/null

                                if [[ $UID -ne 0 && $bits -eq 0 ]]; then
                                        # if we're not read we need this
                                        # otherwise we can't access the dir
                                         _echo2 "Chmod \`$restoredir/$newpath' to 700"
                                        bits="700"
                                fi
                                chmod $bits "$restoredir/$newpath"
                                idir=$(($idir + 1))
                                ;;
                                2)      # LNK
                                if [[ $remote -eq 1 ]]; then
                                        target=$(head -c $fsize)
                                        ln -sf "$target" "$restoredir/$newpath" 
                                else
                                        cp -RP "$path" "$restoredir/$newpath"
                                fi
                                chown -h $uid:$gid "$restoredir/$newpath" 2>/dev/null
                                ilnk=$(($ilnk + 1))
                                ;;
                        esac
                else
                        _echo2 "Ignoring removal of \`$path\'"
                fi
        done 
        te=`date +%s`
        echo "** #REG FILES  : $ireg" >&2
        echo "** #DIRECTORIES: $idir" >&2
        echo "** #LINKS      : $ilnk" >&2
        echo "** SIZE        : $(($ftsize / 1024 )) KB" >&2
        echo "** STORED IN   : $restoredir" >&2
        echo "** ELAPSED     : $(($te - $ts)) s" >&2
}

while getopts ":cvVhp:" options; do
        case $options in
                c) remote=1;;
                v) verbose=1;;
                p) dirstrip=$OPTARG;;
                V) version && exit;;
                h) usage && exit;;
                \?) _echo2 "Invalid option"; usage && exit;;
        esac
done
shift $((OPTIND - 1))

if [[ $# -eq 0 ]]; then
        _echo2 "Need a directory as argument"
        exit 1
fi
if [[ -f $1 ]]; then
        _echo2 "Cannot restore to \`$'" 
        exit 1
fi
if [[ ! $dirstrip =~ "[0-9]+" ]]; then
        _echo2 "Argument to -p must be numeric"
        exit 1
fi
if [[ $dirstrip -lt 0 || $dirstrip -gt 10 ]]; then
        _echo2 "-p argument out of bounds [0..10]"
        exit 1
fi
if [[ ! -e $1 ]]; then
        mkdir $1
        if [[ $? -ne 0 ]]; then
                _echo2 "Cannot create \`$1'"
                exit 1
        fi
fi
restoredir=$1
_restore
