#!/bin/bash

# Copyright (c) 2005, 2006 Miek Gieben
# See LICENSE for the license
#
# Print a filelist suitable for Restore a entire backed up directory
# +MONTHDAY (restore to MONTHDAY's state)

S_ISDIR=16384   # octal: 040000 (This seems to be portable...)
S_ISLNK=40960   # octal: 0120000
S_MMASK=4095    # octal: 00007777, mask to get permission
monthday=0
prevfile=""
PROGNAME=$0

_echo2() {
        echo "** $PROGNAME: $1" >&2
}

cleanup() {
        _echo2 "Signal received while processing \`$basename', exiting" 
        if [[ ! -z $TMPDIR ]]; then
                rm -rf $TMPDIR
        fi
        exit 1
}
# trap at least these
trap cleanup SIGINT SIGPIPE

clean_exit() {
        rm -rf $TMPDIR
        exit 
}

version() {
        echo "$PROGNAME: @PACKAGE_VERSION@ (rdup-utils)"
}

usage() {
        echo "$PROGNAME [OPTIONS] [+DAY]"
        echo
        echo Print a list suitable for restoring
        echo
        echo +DAY - restore up to this month day, defaults to 0
        echo
        echo OPTIONS:
        echo " -c        work with the files' contents (rdup -c)"
        echo " -h        this help"
        echo " -V        print version"
}

sanity_check() {
        # slighty different then in the sh-tools
        if [[ ! "$mode" =~ "[0-9]+" ]]; then
                _echo2 "mode must be numeric"
                exit 1
        fi
        if [[ ! "$psize" =~ "[0-9]+" ]]; then
                _echo2 "psize must be numeric"
                exit 1
        fi
        if [[ ! "$fsize" =~ "[0-9]+" ]]; then
                _echo2 "fsize must be numeric"
                exit 1
        fi
        if [[ ! "$uid" =~ "[0-9]+" || ! "$gid" =~ "[0-9]+" ]]; then
                _echo2 "uid or gid must be numeric"
                exit 1
        fi
}

_seq() {
        j=0
        while [[ $j -le $1 ]] ; do
                echo $j
                j=$(($j + 1))
        done
}

# echo the file's status line to stdout
print_file_status() {
        if [[ $remote -eq 0 ]]; then
                echo -n "${_mode[$1]} ${_uid[$1]} ${_gid[$1]} ${_psize[$1]} ${_fsize[$1]} "
                echo "${_path[$1]}"
        else
                echo "${_mode[$1]} ${_uid[$1]} ${_gid[$1]} ${_psize[$1]} ${_fsize[$1]} "
                echo -n "${_path[$1]}"
                cat_file $1
        fi
}

# cat the file's content to stdout
cat_file() {
        typ=0
        if [[ $((${_mode[$1]} & $S_ISDIR)) == $S_ISDIR ]]; then
                typ=1;
        fi
        if [[ $((${_mode[$1]} & $S_ISLNK)) == $S_ISLNK ]]; then
                typ=2;
        fi
        case $typ in
                0|2)      # REG | LNK
                cat "${_tmp_path[$1]}"
                ;;
                1)      # DIR
                # no content
                ;;
        esac
}

# remove the files stored sofar
rm_tmp_files() {
        if [[ $remote -eq 0 ]]; then
                return
        fi

        for j in $(_seq $1); do
                rm -f "${_tmp_path[$j]}"
        done
}

store() {
        _mode[$i]=$mode
        _uid[$i]=$uid
        _gid[$i]=$gid
        _psize[$i]=$psize
        _fsize[$i]=$fsize
        _path[$i]="$path"
        # don't store the entire path, only the last name
        h=${basename##*/}; _tmp_path[$i]="$TMPDIR/$h.$i"
        _month_e[$i]=$mo; _month_s[$i]=0
        _base[$i]=$basename

        if [[ $remote -eq 0 ]]; then
                return
        fi

        typ=0
        if [[ $(($mode & $S_ISDIR)) == $S_ISDIR ]]; then
                typ=1;
        fi
        if [[ $(($mode & $S_ISLNK)) == $S_ISLNK ]]; then
                typ=2;
        fi
        case $typ in
                0|2)      # REG | LNK
                if [[ $fsize -ne 0 ]]; then
                      # catch
                      head -c $fsize > "${_tmp_path[$i]}"
                else
                      # empty
                      touch "${_tmp_path[$i]}"
                fi
                ;;
                1)      # DIR
                # there is no content
                ;;
        esac
}

_restore() {
        i=0
        declare -a _mode
        declare -a _uid; declare -a _gid
        declare -a _psize; declare -a _fsize
        declare -a _path; declare -a _tmp_path
        declare -a _month_s; declare -a _month_e # monthday interval
        declare -a _base

        while read -r mode uid gid psize fsize
        do
                path=$(head -c $psize)

                sanity_check

                if [[ "$path" =~ "(.+)\\+(..)\\.(..):(..)$" ]]; then
                        basename=${BASH_REMATCH[1]}
                        mo=$((10#${BASH_REMATCH[2]})) # force base 10
                else 
                        basename="$path"
                        mo=32
                fi

                store

                if [[ $i -eq 0 ]]; then
                        # first one read
                        i=$(($i + 1))
                        continue;
                fi
                prev=$(($i - 1))

                if [[ ${_base[$i]} == ${_base[$prev]} ]]; then
                        _month_s[$i]=${_month_e[$prev]}
                        if [[ ${_month_s[$i]} -eq 32 ]]; then
                                # end of month marker, make this 0 for
                                # practical purposes
                                _month_s[$i]=0
                        fi
                        i=$(($i + 1))
                        continue;
                else           
                        x=$(($i - 1))                     
                        smallest_interval=100
                        p=""
                        for j in $(_seq $x); do
                                if [[ $monthday -gt ${_month_s[$j]} &&
                                        $monthday -le ${_month_e[$j]}
                                        ]]; then

                                        interval=$((${_month_e[$j]} - ${_month_s[$j]}))
                                        if [[ $interval -lt $smallest_interval ]]; then
                                                smallest_interval=$interval
                                                p=$j
                                        fi
                                fi
                        done

                        if [[ ! -z $p ]]; then 
                                print_file_status $p
                                rm_tmp_files $x
                        fi      
                        # yes, zero, store, set to 1
                        i=0; store; i=1
                fi
        done
        # last one
        x=$(($i - 1))                     
        smallest_interval=100
        p=""
        for j in $(_seq $x); do
                if [[ $monthday -gt ${_month_s[$j]} &&
                        $monthday -le ${_month_e[$j]}
                        ]]; then

                        interval=$((${_month_e[$j]} - ${_month_s[$j]}))
                        if [[ $interval -lt $smallest_interval ]]; then
                                smallest_interval=$interval
                                p=$j
                        fi
                fi
        done

        if [[ ! -z $p ]]; then 
                print_file_status $p
                rm_tmp_files $x
        fi      
}

remote=0
while getopts ":Vch" o; do
        case $o in
                c) remote=1;;
                h) usage && exit;;
                V) version && exit;;
                \?) _echo2 "Invalid option"; usage && exit;;
        esac
done
shift $((OPTIND - 1))

if [[ $# -eq 1 ]]; then
        # we have a + argument
        if [[ $1 =~ "\\+(.+)" ]]; then
                monthday=${BASH_REMATCH[1]}
                if [[ ! $monthday =~ "[0-9]+" ]]; then
                        _echo2 "+DAY must be numerical"
                        exit 1
                fi
        else
                _echo2 "Need a +DAY argument"
                exit 1
        fi
fi

if [[ $monthday -lt 0 || $monthday -gt 31 ]]; then
        _echo2 "+DAY out of bounds [0..31]"
       exit 1
fi

# hackish. This makes +0 work correctly
if [[ $monthday -eq 0 ]]; then
        monthday=32
fi

if [[ $remote -eq 0 ]]; then
        _restore
else
        TMPDIR=`mktemp -d "/tmp/rdup.restore.XXXXXX"`
        if [[ $? -ne 0 ]]; then
                _echo2 "Mktemp failed"
                exit 1
        fi
        chmod 700 $TMPDIR
        _restore
fi
