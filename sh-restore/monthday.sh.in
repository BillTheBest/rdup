#!/bin/bash

# Copyright (c) 2005, 2006 Miek Gieben
# See LICENSE for the license
#
# Print a filelist suitable for Restore a entire backed up directory
# +MONTHDAY (restore to MONTHDAY's state)

S_ISDIR=16384   # octal: 040000 (This seems to be portable...)
S_ISLNK=40960   # octal: 0120000
S_MMASK=4095    # octal: 00007777, mask to get permission
monthday=0
prevfile=""
PROGNAME=$0

_echo2() {
        echo "** $PROGNAME: $1" >&2
}

cleanup() {
        _echo2 "Signal received while processing \`$basename', exiting" 
        if [[ ! -z $TMPDIR ]]; then
                rm -rf $TMPDIR
        fi
        exit 1
}
# trap at least these
trap cleanup SIGINT SIGPIPE

clean_exit() {
        rm -rf $TMPDIR
        exit 
}

usage() {
        echo "$PROGNAME [OPTIONS] [+DAY]"
        echo
        echo Print a list suitable for restoring
        echo
        echo +DAY - restore up to this month day, defaults to 0
        echo
        echo OPTIONS:
        echo " -c        work with the files' contents (rdup -c)"
        echo " -h        this help"
        echo " -V        print version"
}

sanity_check() {
        # slighty different then in the sh-tools
        if [[ ! "$mode" =~ "[0-9]+" ]]; then
                _echo2 "mode must be numeric"
                exit 1
        fi
        if [[ ! "$psize" =~ "[0-9]+" ]]; then
                _echo2 "psize must be numeric"
                exit 1
        fi
        if [[ ! "$fsize" =~ "[0-9]+" ]]; then
                _echo2 "fsize must be numeric"
                exit 1
        fi
        if [[ ! "$uid" =~ "[0-9]+" || ! "$gid" =~ "[0-9]+" ]]; then
                _echo2 "uid or gid must be numeric"
                exit 1
        fi
}

version() {
        echo "$PROGNAME: @PACKAGE_VERSION@ (rdup-utils)"
}

_seq() {
        j=0
        while [[ $j -le $1 ]] ; do
                echo $j
                j=$(($j + 1))
        done
}

# echo the file's status line to stdout
print_file_status() {
        if [[ $remote -eq 0 ]]; then
                echo -n "${_mode[$1]} ${_uid[$1]} ${_gid[$1]} ${_psize[$1]} ${_fsize[$1]} "
                echo "${_path[$1]}"
        else
                echo "${_mode[$1]} ${_uid[$1]} ${_gid[$1]} ${_psize[$1]} ${_fsize[$1]} "
                echo -n "${_path[$1]}"
        fi
}

# cat the file's content to stdout
cat_file() {
        typ=0
        if [[ $((${_mode[$1]} & $S_ISDIR)) == $S_ISDIR ]]; then
                typ=1;
        fi
        if [[ $((${_mode[$1]} & $S_ISLNK)) == $S_ISLNK ]]; then
                typ=2;
        fi
        case $typ in
                0|2)      # REG | LNK
                cat "${_tmp_path[$1]}"
                ;;
                1)      # DIR
                # no content
                ;;
        esac
}

# remove the files stored sofar
rm_tmp_files() {
        for j in $(_seq $1); do
                rm -f "${_tmp_path[$j]}"
        done
}

store() {
        _mode[$i]=$mode
        _uid[$i]=$uid
        _gid[$i]=$gid
        _psize[$i]=$psize
        _fsize[$i]=$fsize
        _path[$i]="$path"
        # don't store the entire path, only the last name
        h=${basename##*/}
        _tmp_path[$i]="$TMPDIR/$h.$i"
        _month[$i]=$mo

        prevfile=$basename

        if [[ $remote -eq 0 ]]; then
                return
        fi

        typ=0
        if [[ $(($mode & $S_ISDIR)) == $S_ISDIR ]]; then
                typ=1;
        fi
        if [[ $(($mode & $S_ISLNK)) == $S_ISLNK ]]; then
                typ=2;
        fi
        case $typ in
                0|2)      # REG | LNK
                if [[ $fsize -ne 0 ]]; then
                      # catch
                      head -c $fsize > "${_tmp_path[$i]}"
                else
                      # empty
                      touch "${_tmp_path[$i]}"
                fi
                ;;
                1)      # DIR
                # there is no content
                ;;
        esac
}

local_restore() {
        i=0
        declare -a _mode
        declare -a _uid
        declare -a _gid
        declare -a _psize
        declare -a _fsize
        declare -a _path
        declare -a _tmp_path
        declare -a _month

        # store everything you get, until we hit
        # a new name. Then process what we've got
        # and get on with the newer one
        #
        # all the filenames are received in ascending
        # order

        while read -r mode uid gid psize fsize path
        do
                sanity_check

                if [[ "$path" =~ "(.+)\\+(..)\\.(..):(..)$" ]]; then
                        basename=${BASH_REMATCH[1]}
                        mo=$((10#${BASH_REMATCH[2]})) # force base 10
                else 
                        basename="$path"
                        mo=0
                fi

                # first hit
                if [[ -z "$prevfile" ]]; then
                        store $i
                        i=$(($i + 1))
                        continue
                fi

                if [[ "$prevfile" != "$basename" ]]; then
                        # a new file has been seen. Figure out what to
                        # do with the ones we have

                        # the first one is the one without suffix
                        if [[ $monthday -eq 0 ]]; then
                                print_file_status 0
                                i=0; store $i
                                continue
                        fi

                        if [[ $monthday -gt ${_month[$i]} ]]; then
                                # after any of the versions, use the
                                # plain one
                                print_file_status 0
                                i=0; store $i
                                continue
                        fi
                        
                        # need 1 loop, for exact match
                        # another for in between match
                        for j in $(_seq $i); do
                                if [[ $monthday -eq ${_month[$j]} ]]; then
                                        # exact match
                                        print_file_status $j       
                                        i=0; store $i
                                        continue 2
                                fi
                        done
                        # get in between value
                        for j in $(_seq $i); do
                                if [[ ${_month[$j]} -gt $monthday ]]; then
                                        x=$(($j - 1))
                                        if [[ $x -lt 0 ]]; then 
                                                x=0
                                        fi
                                        print_file_status $x
                                        i=0; store $i
                                        continue 2
                                fi
                        done
                        
                        # nothing matched, because $monthday is smaller
                        # than any of the months we have, use the first
                        # stored version.

                        if [[ ${_month[1]} -eq 0 ]]; then
                                _echo2 "Huh this should have a value!"
                                print_file_status 0
                                i=0; store $i
                                continue
                        else 
                                print_file_status 1
                                i=0; store $i
                                continue
                        fi
                else 
                        i=$(($i + 1))
                        store $i
                fi
        done
        # this is need for the last file we've just read
        if [[ $monthday -eq 0 ]]; then
                print_file_status 0
                clean_exit
        fi
        if [[ $monthday -gt ${_month[$i]} ]]; then
                # after any of the versions, use the
                # plain one
                print_file_status 0
                clean_exit
        fi

        for j in $(_seq $i); do
                if [[ $monthday -eq ${_month[$j]} ]]; then
                        # exact match
                        print_file_status $j       
                        clean_exit
                fi
                if [[ $monthday -gt ${_month[$j]} ]]; then
                        x=$(($j - 1))
                        print_file_status $x
                        clean_exit
                fi
        done

        if [[ ${_month[1]} -eq 0 ]]; then
                _echo2 "Huh this should have a value!"
                print_file_status 0
                clean_exit
        else 
                print_file_status 1
                clean_exit
        fi
}

remote_restore() {
        i=0
        declare -a _mode
        declare -a _uid
        declare -a _gid
        declare -a _psize
        declare -a _fsize
        declare -a _path
        declare -a _tmp_path
        declare -a _month
        # work dir
        TMPDIR=`mktemp -d "/tmp/rdup.restore.XXXXXX"`
        if [[ $? -ne 0 ]]; then
                _echo2 "Mktemp failed" 
                exit 1
        fi
        chmod 700 $TMPDIR

        # store everything you get, until we hit
        # a new name. Then process what we've got
        # and get on with the newer one
        #
        # all the filenames are received in ascending
        # order

        while read -r mode uid gid psize fsize
        do
                path=$(head -c $psize)

                sanity_check
                
                if [[ "$path" =~ "(.+)\\+(..)\\.(..):(..)$" ]]; then
                        basename=${BASH_REMATCH[1]}
                        mo=$((10#${BASH_REMATCH[2]})) # force base 10
                else 
                        basename="$path"
                        mo=0
                fi

                # first hit
                if [[ -z "$prevfile" ]]; then
                        store $i
                        i=$(($i + 1))
                        continue
                fi

                if [[ "$prevfile" != "$basename" ]]; then
                        # a new file has been seen. Figure out what to
                        # do with the ones we have

                        # the first one is the one without suffix
                        if [[ $monthday -eq 0 ]]; then
                                print_file_status 0
                                cat_file 0
                                rm_tmp_files $i
                                i=0; store $i
                                continue
                        fi

                        if [[ $monthday -gt ${_month[$i]} ]]; then
                                # after any of the versions, use the
                                # plain one
                                print_file_status 0
                                cat_file 0
                                rm_tmp_files $i
                                i=0; store $i
                                continue
                        fi
                        
                        # need 1 loop, for exact match
                        # another for in between match
                        for j in $(_seq $i); do
                                if [[ $monthday -eq ${_month[$j]} ]]; then
                                        # exact match
                                        print_file_status $j       
                                        cat_file $j
                                        rm_tmp_files $i
                                        i=0; store $i
                                        continue 2
                                fi
                        done
                        # get in between value
                        for j in $(_seq $i); do
                                if [[ ${_month[$j]} -gt $monthday ]]; then
                                        x=$(($j - 1))
                                        if [[ $x -lt 0 ]]; then 
                                                x=0
                                        fi
                                        print_file_status $x
                                        cat_file $x
                                        rm_tmp_files $i
                                        i=0; store $i
                                        continue 2
                                fi
                        done
                        
                        # nothing matched, because $monthday is smaller
                        # than any of the months we have, use the first
                        # stored version.

                        if [[ ${_month[1]} -eq 0 ]]; then
                                _echo2 "Huh this should have a value!"
                                print_file_status 0
                                cat_file 0
                                rm_tmp_files $i
                                i=0; store $i
                                continue
                        else 
                                print_file_status 1
                                cat_file 1
                                rm_tmp_files $i
                                i=0; store $i
                                continue
                        fi
                else 
                        i=$(($i + 1))
                        store $i
                fi
        done
        # this is need for the last file we've just read
        if [[ $monthday -eq 0 ]]; then
                print_file_status 0
                cat_file 0
                rm_tmp_files $i
                clean_exit
        fi
        if [[ $monthday -gt ${_month[$i]} ]]; then
                # after any of the versions, use the
                # plain one
                print_file_status 0
                cat_file 0
                rm_tmp_files $i
                clean_exit
        fi

        for j in $(_seq $i); do
                if [[ $monthday -eq ${_month[$j]} ]]; then
                        # exact match
                        print_file_status $j       
                        cat_file $j
                        rm_tmp_files $i
                        clean_exit
                fi
                if [[ $monthday -gt ${_month[$j]} ]]; then
                        x=$(($j - 1))
                        print_file_status $x
                        cat_file $x
                        rm_tmp_files $i
                        clean_exit
                fi
        done

        if [[ ${_month[1]} -eq 0 ]]; then
                _echo2 "Huh this should have a value!"
                print_file_status 0
                cat_file 0
                rm_tmp_files $i
                clean_exit
        else 
                print_file_status 1
                cat_file 1
                rm_tmp_files $i
                clean_exit
        fi
}

remote=0
while getopts ":Vch" o; do
        case $o in
                c) remote=1;;
                h) usage && exit;;
                V) version && exit;;
                \?) _echo2 "Invalid option"; usage && exit;;
        esac
done
shift $((OPTIND - 1))

if [[ $# -eq 1 ]]; then
        # we have a + argument
        if [[ $1 =~ "\\+(.+)" ]]; then
                monthday=${BASH_REMATCH[1]}
                if [[ ! $monthday =~ "[0-9]+" ]]; then
                        _echo2 "+DAY must be numerical"
                        exit 1
                fi
        else
                _echo2 "Need a +DAY argument"
                exit 1
        fi
fi

if [[ $monthday -lt 0 || $monthday -gt 31 ]]; then
        _echo2 "+DAY out of bounds [0..31]"
        exit 1
fi

if [[ $remote -eq 0 ]]; then
        local_restore
else
        remote_restore
fi
