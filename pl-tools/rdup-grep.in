#!/usr/bin/perl -w
#
# Copyright (c) 2005, 2006 Miek Gieben; Mark J Hewitt
# See LICENSE for the license
#
# grep rdup output
#
use strict;

use Getopt::Std;
use File::Basename;
use File::Temp qw{tempdir tempfile};
use File::Spec;

# common functions
my $prefix="@prefix@";
require "@datadir@/rdup/shared.pl" or die "** Require \`shared.pl' failed";

my $progName = basename $0;

my %opt;
my ($remote, $verbose, $invert);

getopts('cihvV', \%opt);
usage() if $opt{'h'};
version($progName) if $opt{'V'};
$verbose = $opt{'v'};
$remote = $opt{'c'};
$invert = $opt{'i'};
my ($mode, $uid, $gid, $psize, $fsize, $path, $target);
my $REG = $ARGV[0];

if (defined($ARGV[0])) {
        $REG = $ARGV[0];
} else {
        die "** Need an regular expression";
}

if ($remote) {
        while (($_ = <STDIN>)) {
                chomp;
                ($t, $bits, $uid, $gid, $psize, $fsize) = split(" ", $_, 6);
                _grep();
        }
} else {
        while (($_ = <STDIN>)) {
                chomp;
                ($t, $bits, $uid, $gid, $psize, $fsize, $path) = split(" ", $_, 7);
                _grep();
        }
}
exit 0;

sub _grep {
        my $dump = substr($t, 0, 1);
        my $type = substr($t, 1, 1);

        sanity_check($dump, $bits, $psize, $fsize, $uid, $gid);

        if ($remote) {
                $path = "";
                read STDIN, $path, $psize;
        }

        print STDERR "$path\n" if $verbose;
        die "** Empty path"  if ($path eq "");

        my $match = 0;
        if ($dump eq '+') {        # add
                if ($path =~ /$REG/) { $match = 1; }
                if ($invert) { $match = ! $match; }
                if ($match == 0) { return; }

                if ($type eq '-') {      # REG
                        if ($fsize != 0 and $remote) {
                                syswrite STDOUT, "$dump$type $bits $uid $gid $psize $fsize\n$path";
                                copyout($fsize, *STDOUT);
                                return;
                        }
                        if ($remote) {
                                syswrite STDOUT, "$dump$type $bits $uid $gid $psize $fsize\n$path";
                                return;
                        }
                        syswrite STDOUT, "$dump$type $bits $uid $gid $psize $fsize $path\n";
                        return;
                } elsif ($type eq 'd') {      # DIR
                        if ($remote) {
                                syswrite STDOUT, "$dump$type $bits $uid $gid $psize $fsize\n$path";
                                return;
                        }
                        syswrite STDOUT, "$dump$type $bits $uid $gid $psize $fsize $path\n";
                        return;
                } elsif ($typ eq 'l') {      # LNK
                        if ($remote) {
                                read STDIN, $target, $fsize;
                                syswrite STDOUT, "$dump$type $bits $uid $gid $psize $fsize\n$path$target";
                                return;
                        }
                        syswrite STDOUT, "$dump$type $bits $uid $gid $psize $fsize $path\n";
                }
        } else {
                if ($remote) {
                        syswrite STDOUT, "$dump$type $bits $uid $gid $psize $fsize\n$path";
                }
                syswrite STDOUT, "$dump$type $bits $uid $gid $psize $fsize $path\n";
        }
}

sub usage {
        print "$progName [OPTIONS] REGEXP\n\n";
        print "Grep rdup's output using REGEXP\n\n";
        print "OPTIONS:\n";
        print " -c    also process the files' content (rdup -c)\n";
        print " -i    invert, print all what doesn't match\n";
        print " -v    echo the files process to standard error\n";
        print " -h    this help\n";
        print " -V    print version\n";
        exit;
}
