#!/usr/bin/perl -w
#
# Copyright (c) 2005 - 2007 Miek Gieben
# See LICENSE for the license

# todo; robustness, error checking
use strict;

use Net::Amazon::S3;

use Getopt::Std;
use File::Basename;
use File::Temp qw{tempdir tempfile};
use POSIX;

# common functions
my $prefix="@prefix@";
my $datarootdir = "@datarootdir@";
require "@datadir@/rdup/shared.pl"; 

my $progName = basename $0;
my %opt;
my $d = i18n();


# options
# -b bucketname
# -k keyid_file
# -s secret_key_id_file

# then:
# upload | download | delete | list  [filename]

# localname is remote name?

#
# -f rdup-backup-filename

# -l (standalone - list files in bucket named

# -c (dump the output on stdout)

# hV



# connect to amazon
# key id, secret key
sub s3connect($$) {
    my $s3 = Net::Amazon::S3->new( 
	{
	aws_access_key_id => shift,
	aws_secret_access_key => shift,
	}
    );

    if (! $s3) {
        die "** Could not connect to S3";
    }
    $s3;
}

# get a file from a bucket
# bucket, filename, localname
sub s3get($$$) {
    my $bucket = shift;
    my $response = $bucket->get_key_filename(shift, 'GET', shift);
}

# bucket, filename, localname
sub s3put($$$) {
    my $bucket = shift;
    my $response = $bucket->add_key_filename(shift, shift,
	    {  content_type => 'application/binary', },
	    );
}

# create a bucket
# s3 obj, bucket name (string)
sub s3bucket($$) {
    my $s3 = shift;
    my $response = $s3->add_bucket( { bucket => shift } ) or 
	    die $s3->err . ": " . $s3->errstr;

}

# bucket object
sub s3list_files($) {
    my $bucket = shift;

    my $r = $bucket->list_all;
    my @keys = @{ $r->{keys} };
    my @files;
    foreach (@keys) {
	push @files, $_->{keys};
    }
    @files;
}

# return a list of buckets
# s3 object
sub s3list_buckets($) {
    my $s3 = shift;
    my $r = $s3->buckets;

    @ { $r->{buckets} };
}



getopts('dhV', \%opt);
usage() if $opt{'h'};
version($progName) if $opt{'V'};
my $crOptions = "-e ";
$crOptions = "-d " if $opt{'d'};
$crOptions .= "--use-agent " if $opt{'a'};

`which gpg >/dev/null`;
if ($? != 0) {
        die "** Cannot find \'gpg'";
}

my $default="--default-recipient-self";
if (defined($ARGV[0])) {
	$default="--default-recipient $ARGV[0]";
}

$crOptions .= "-q $default";

my $tmpDir = tempdir("rdup.gpg.XXXXXX", TMPDIR => 1, CLEANUP => 1);
die $d->get("** could not create:") . " $tmpDir: $!" unless -d $tmpDir;

while (($_ = <STDIN>)) {
        chomp;
        my ($t, $bits, $uid, $gid, $psize, $fsize) = split(" ", $_, 6);
        my $dump = substr($t, 0, 1);
        my $type = substr($t, 1, 1);

        sanity_check($dump, $bits, $psize, $fsize, $uid, $gid);

        my $path = "";
        read STDIN, $path, $psize;
        die $d->get("** Empty path") if ($path eq "");

        if ($dump eq '+') {        # add
                if ($type eq '-') {      # REG
                        if ($fsize != 0) {
                                my($fh, $filename) = tempfile("file.XXXXX", DIR => $tmpDir, SUFFIX => ".gpg" );
                                $fh->close();
                                open CRYPT, "|gpg $crOptions 2>/dev/null > $filename" or die "** $filename: $!";
                                copyout($fsize, *CRYPT);
                                close CRYPT or warn "** Crypt failure: result will be empty \`$path': $!";
                                my $size = (stat($filename))[7];
                                syswrite STDOUT, "$dump$type $bits $uid $gid $psize $size\n$path";
                                catfile($filename);
                                unlink $filename;
                                next;
                        }
                        syswrite STDOUT, "$dump$type $bits $uid $gid $psize $fsize\n$path";
                        next;
                }
        } 
	syswrite STDOUT, "$dump$type $bits $uid $gid $psize $fsize\n$path";
}

sub usage {
        print "$progName [OPTIONS] [RECIPIENT]\n\n";
        print "Encrypt or decrypt the file's contents with the\n";
        print "default public key in your key ring\n";
	print "RECIPIENT - recipient name to use for GPG\n";
	print "            defaults to self\n";
        print "\nOPTIONS:\n";
        print " -c    ignored as rdup-gpg always works on content\n";
        print " -a    use gpg-agent (needed when decrypting a lot files)\n";
        print " -d    decrypt the files\n";
        print " -h    this help\n";
        print " -V    print version\n";
        exit;
}
