#!/usr/bin/perl -w
#
# Copyright (c) 2005 - 2007 Miek Gieben
# See LICENSE for the license

# todo; robustness, error checking
use strict;
use Net::Amazon::S3;

use Getopt::Long;
use File::Basename;
use File::Temp qw{tempdir tempfile};
use POSIX;

# common functions
my $prefix="/usr";
my $datarootdir = "${prefix}/share";
require "@datadir@/rdup/shared.pl"; 

my $progName = basename $0;
my %opt;
my $d = i18n();

# connect to amazon
# key id, secret key
sub s3connect($$) {
    my $s3 = Net::Amazon::S3->new( 
	{
	aws_access_key_id => shift,
	aws_secret_access_key => shift,
	}
    );

    if (! $s3) {
        die "** Could not connect to S3";
    }
    $s3;
}

# get a file from a bucket
# bucket, filename, localname
sub s3get($$$) {
    my $bucket = shift;
    my $response = $bucket->get_key_filename(shift, 'GET', shift);
}

# bucket, filename, localname
sub s3put($$$) {
    my $bucket = shift;
    my $response = $bucket->add_key_filename(shift, shift,
	    {  content_type => 'application/binary', },
	    );
}

# create a bucket
# s3 obj, bucket name (string)
sub s3bucket($$) {
    my $s3 = shift;
    my $response = $s3->add_bucket( { bucket => shift } ) or 
	    die $s3->err . ": " . $s3->errstr;
}

# bucket object
sub s3list_files($) {
    my $bucket = shift;

    my $r = $bucket->list_all;
    my @keys = @{ $r->{keys} };
    my @files;
    foreach (@keys) {
	push @files, $_->{keys};
    }
    @files;
}

# return a list of buckets
# s3 object
sub s3list_buckets($) {
    my $s3 = shift;
    my $r = $s3->buckets;

    @ { $r->{buckets} };
}

# options
# -b bucketname
# -k keyid_file
# -s secret_key_id_file

# then:
# up | get | rm | ls  [filename]

# filename is remote name

# hV


my ($bucket, $help, $version, $key, $secret);
GetOptions('b=s' => \$bucket,
	   'k=s' => \$key,
	   's=s' => \$secret,
	   'h'	 => \$help,
	   'V'	 => \$version
	);
usage() if $help || !$bucket || !$key || !$secret;
version($progName) if $version;

# re-use the names
foreach ($key, $secret) {
    open IN, "<", $_ or die $d-get("Can not open: ") . "$_: $!";
	my $a = <IN>; # only the first line is read
	chomp $a;
    close IN;
    $_ = $a; # eeeuw! But it works
}

print "key:\n$key\n";
print "secret:\n$secret\n";

# next we have are command, get, put, rm, ls 
# and maybe a filename
# for get and put we need one, for rm and ls
# we can ignore the file, in that case we list
# the bucket

my %ops = qw/get 1 put 1 rm 1 ls 1/;
if (! $ops{$ARGV[0]} ) {
    die $d->get("** No valid mode given: \`$ARGV[0]\'");
} 
my $O = shift;

if ($O eq "get" || $O eq "put") {
    if (! $ARGV[0] ) {
	die $d->get("** A filename is required with \`get' and \`put'");
    }

    my 

    # get, put
    # check bucket, create one if needed

    exit 0;
}

if ($O eq "ls" || $O eq "rm") {



}


exit;
# check if the buckup exists, if not create it
# check what we need to do
# up or download the file

my $tmpDir = tempdir("rdup.s3.XXXXXX", TMPDIR => 1, CLEANUP => 1);
die $d->get("** could not create:") . " $tmpDir: $!" unless -d $tmpDir;




# read STDIN and save it in the file
my ($n, $buf, $file);
$file = "$tmpDir/rdup.$$.s3";
open OUT, "> $file" or die $d->get("** could not open:") . " $file: $!";
while (($n = read STDIN, $buf, 4096) > 0) {
    syswrite OUT, $buf, $n;
}
close OUT;
print $file, "\n";


sub usage {
        print "$progName -b BUCKET -k KEY -s SECRET [OPTIONS] put|get|rm|ls [FILENAME]\n\n";
        print "Up- or download file to or from Amazon's S3 service\n";
	print "BUCKET - name of the bucket to use\n";
	print "KEY    - file containing your S3 id\n";
	print "SECRET - file containing your private S3 key\n";
        print "\nOPTIONS:\n";
        print " -c    ignored as rdup-s3 always works on content\n";
        print " -h    this help\n";
        print " -V    print version\n";
        exit;
}
