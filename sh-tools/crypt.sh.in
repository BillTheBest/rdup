#!/bin/bash
#
# Copyright (c) 2005, 2006 Miek Gieben
# See LICENSE for the license
#
# zip rdup -c's output

prefix=@prefix@
exec_prefix=@exec_prefix@
datadir=@datadir@/rdup
# shared stuff
source $datadir/shared.sh

PROGNAME=$0
OPT=""

# trap at least these
trap cleanup SIGINT SIGPIPE

usage() {
        echo "$PROGNAME [OPTIONS] KEYFILE"
        echo
        echo "Encrypt or decrypt the file's contents with the"
        echo "key stored in KEYFILE"
        echo
        echo OPTIONS:
        echo " -c    ignored as crypt.sh always works on content"
        echo " -d    decrypt the files"
        echo " -h    this help"
        echo " -V    print version"
}

_stat_size() {
        case $OSTYPE in
                linux*)
                        echo $(stat --format "%s" "$@")
                ;;
                freebsd*)
                        echo $(stat -f "%z" "$@")
                ;;
        esac
}

while getopts ":cdVh" o; do
        case $o in
                d) OPT="-d";;
                h) usage && exit;;
                V) version && exit;;
                \?) _echo2 "Invalid option: $OPTARG"; usage && exit;;
        esac
done
shift $((OPTIND - 1))

# 1 argument keyfile used for encryption
if [[ $# -eq 0 ]]; then
        _echo2 "Need a keyfile as argument"
        exit 1
fi
if [[ ! -r $1 ]]; then
        _echo2 "Cannot read keyfile \`$1': failed"
        exit 1
fi

TMPDIR=`mktemp -d "/tmp/rdup.backup.XXXXXX"`
if [[ $? -ne 0 ]]; then
        _echo2 "** $0: mktemp failed" 
        exit 1
fi
chmod 700 $TMPDIR

while read -r mode uid gid psize fsize
do
        dump=${mode:0:1}        # to add or remove
        mode=${mode:1}          # st_mode bits
        typ=0
        read -r -n $psize path  # get the path

        sanity_check

        if [[ $(($mode & $S_ISDIR)) == $S_ISDIR ]]; then
                typ=1;
        fi
        if [[ $(($mode & $S_ISLNK)) == $S_ISLNK ]]; then
                typ=2;
        fi
        if [[ $dump == "+" ]]; then
                # add
                case $typ in
                        0)      # REG
                        if [[ $fsize -ne 0 ]]; then
                                # catch 'n crypt
                                dd bs=1 count=$fsize 2>/dev/null | \
                                mcrypt -q $OPT -F -f "$1" -a blowfish > $TMPDIR/file.$$.enc || \
                                exit 1

                                newsize=$(_stat_size $TMPDIR/file.$$.enc)
                                echo "$dump$mode $uid $gid $psize $newsize"
                                echo -n "$path"
                                cat $TMPDIR/file.$$.enc
                                rm -f $TMPDIR/file.$$.enc
                        else
                                # no content
                                echo "$dump$mode $uid $gid $psize $fsize"
                                echo -n "$path"
                        fi
                        ;;
                        1)      # DIR
                        echo "$dump$mode $uid $gid $psize $fsize"
                        echo -n "$path"
                        ;;
                        2)      # LNK, target is in the content!
                        read -r -n $fsize target
                        echo "$dump$mode $uid $gid $psize $fsize"
                        echo -n "$path"
                        echo -n "$target"
                        ;;
                esac
        else
                # there is no content
                echo "$dump$mode $uid $gid $psize $fsize"
                echo -n "$path"
        fi
done

rm -rf $TMPDIR
exit 0
