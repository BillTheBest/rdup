#!/bin/bash
#
# Copyright (c) 2005, 2006 Miek Gieben
# See LICENSE for the license
#
# This script implement a mirroring backup scheme
# -c is used for remote mirroring

S_ISDIR=16384   # octal: 040000 (This seems to be portable...)
S_ISLNK=40960   # octal: 0120000
S_MMASK=4095    # octal: 00007777, mask to get permission

remote=0
verbose=0
idir=0; ireg=0; ilnk=0; irm=0
ftsize=0
attr=0          # use attr to save original uid/gid
attr_there=0
ts=`date +%s` 
backupdir=""
PROGNAME=$0
cstream=@cstream@

_echo2() {
        echo "** $PROGNAME: $1" >&2
}

# check if attr can be found
check_attr() {
        case $OSTYPE in
                linux*)
                which attr > /dev/null
                if [[ $? -eq 0 ]]; then
                        attr_there=1
                else
                        attr_there=0
                fi
                ;;
                *)
                attr_there=0
                _echo2 "Can not set extended attributes"
                ;;
        esac
}

cleanup() {
        _echo2 "Signal received while processing \`$path', exiting" 
        exit 1
}
# trap at least these
trap cleanup SIGINT SIGPIPE

set_attr_uid() {
        if [[ $attr_there -eq 0 ]]; then
                return
        fi
        value=$1
        shift
        case $OSTYPE in
                linux*)
                attr -q -s r_uid -V$value "$@"      
                ;;
                *)
                ;;
        esac
}

set_attr_gid() {
        if [[ $attr_there -eq 0 ]]; then
                return
        fi
        value=$1
        shift
        case $OSTYPE in
                linux*)
                attr -q -s r_gid -V$value "$@"      
                ;;
                *)
                ;;
        esac
}

# set the extended attributes
chown_attr() {
        uid=$1
        gid=$2
        shift; shift

        if [[ $attr -eq 0 ]]; then
                return
        fi
        set_attr_uid $uid "$@"
        set_attr_gid $gid "$@"
}

mirror_suffix() {
        case $OSTYPE in
                linux*)
                        s=$(stat -c '%y' "$@")  
                        echo "+${s:8:2}.${s:11:5}"
                ;;
                freebsd*)
                        s=$(stat -f '%Sm' "$@")
                        # add prefix 0
                        printf "+%02d.%s" ${s:4:2} ${s:7:5}
                ;;
        esac
}

mirror_create_top() {
        # need to reverse the order
        dir=$1;
        while [[ $dir != "/" ]]
        do
                dirs="$dir $dirs"
                dir=`dirname $dir`
        done
        for d in $dirs; do
                if [[ ! -d $d ]]; then
                        mkdir -m 755 "$d"
                        chown root:backup "$d"
                fi
        done
}

usage() {
        echo "$PROGNAME [OPTIONS]"
        echo
        echo Mirror the files from the filelist of rdup
        echo
        echo OPTIONS
        echo " -a      write extended attributes r_uid/r_gid with uid/gid"
        echo " -c      process the file content also (rdup -c), for remote backups"
        echo " -b DIR  use DIR as the backup directory, YYYYMM will be added"
        echo " -v      echo the files processed to stderr"
        echo " -h      this help"
        echo " -V      print version"        
}

version() {
        echo "** $PROGNAME: @PACKAGE_VERSION@ (rdup-utils)"
}

sanity_check() {
        if [[ $dump != "+" && $dump != "-" ]]; then
                _echo2 "dump must be + or -"
                exit 1
        fi
        if [[ ! "$mode" =~ "[0-9]+" ]]; then
                _echo2 "mode must be numeric"
                exit 1
        fi
        if [[ ! "$psize" =~ "[0-9]+" ]]; then
                _echo2 "psize must be numeric"
                exit 1
        fi
        if [[ ! "$fsize" =~ "[0-9]+" ]]; then
                _echo2 "fsize must be numeric"
                exit 1
        fi
        if [[ ! "$uid" =~ "[0-9]+" || ! "$gid" =~ "[0-9]+" ]]; then
                _echo2 "uid or gid must be numeric"
                exit 1
        fi
}

local_mirror() {
        declare -a path # catch spacing in the path
        while read -r mode uid gid psize fsize path
        do
                dump=${mode:0:1}                # to add or remove
                mode=${mode:1}                  # st_mode bits

                sanity_check

                bits=$(($mode & $S_MMASK))      # permission bits
                bits=`printf "%o" $bits`        # and back to octal again
                typ=0

                if [[ $(($mode & $S_ISDIR)) == $S_ISDIR ]]; then
                        typ=1;
                fi
                if [[ $(($mode & $S_ISLNK)) == $S_ISLNK ]]; then
                        typ=2;
                fi
                
                [[ $verbose -eq 1 ]] && echo $path >&2

                if [[ -e "$backupdir/$path" ]]; then
                        suffix=`mirror_suffix "$backupdir/$path"`
                fi

                if [[ $dump == "+" ]]; then
                        # add
                        case $typ in
                                0)      # REG
                                if [[ -e "$backupdir/$path" ]]; then
                                        # attributes are preserved when
                                        # moving
                                        mv "$backupdir/$path" "$backupdir/$path$suffix"
                                fi
                                cp -RP "$path" "$backupdir/$path"
                                chown $uid:$gid "$backupdir/$path" 2>/dev/null
                                chown_attr $uid $gid "$backupdir/$path" 
                                chmod $bits "$backupdir/$path"
                                ftsize=$(($ftsize + $fsize))
                                ireg=$(($ireg + 1))
                                ;;
                                1)      # DIR
                                # check for fileTYPE changes
                                if [ -f "$backupdir/$path" -o -L "$backupdir/$path" ]; then
                                        mv "$backupdir/$path" "$backupdir/$path$suffix"
                                fi

                                [[ ! -d "$backupdir/$path" ]] && mkdir -p "$backupdir/$path" 
                                chown $uid:$gid "$backupdir/$path" 2>/dev/null
                                chown_attr $uid $gid "$backupdir/$path" 

                                if [[ $UID -ne 0 && $bits -eq 0 ]]; then
                                        # if we're not read we need this
                                        # otherwise we can't access the dir
                                        _echo2 "Chmod \`$backupdir/$path' to 700"
                                        bits="700"
                                fi
                                chmod $bits "$backupdir/$path"
                                idir=$(($idir + 1))
                                ;;
                                2)      # LNK
                                if [[ -e "$backupdir/$path" ]]; then
                                        mv "$backupdir/$path" "$backupdir/$path$suffix"
                                fi
                                cp -RP "$path" "$backupdir/$path"
                                chown -h $uid:$gid "$backupdir/$path" 2>/dev/null
                                chown_attr $uid $gid "$backupdir/$path" 
                                ilnk=$(($ilnk + 1))
                                ;;
                        esac
                else
                        # move. It could be the stuff is not there, don't
                        # error on that.
                        if [[ -e "$backupdir/$path" ]]; then
                                mv "$backupdir/$path" "$backupdir/$path$suffix"
                        fi
                        irm=$(($irm + 1))
                fi
        done 
        te=`date +%s`
        echo "** #REG FILES  : $ireg" >&2
        echo "** #DIRECTORIES: $idir" >&2
        echo "** #LINKS      : $ilnk" >&2
        echo "** #(RE)MOVED  : $irm"  >&2
        echo "** SIZE        : $(($ftsize / 1024 )) KB"  >&2
        echo "** STORED IN   : $backupdir"  >&2
        echo "** ELAPSED     : $(($te - $ts)) s" >&2
}

remote_mirror() {
        while read -r mode uid gid psize fsize
        do
                dump=${mode:0:1}        # to add or remove
                mode=${mode:1}          # st_mode bits
                read -r -n $psize path  # get the path

                sanity_check

                bits=$(($mode & $S_MMASK)) # permission bits
                bits=`printf "%o" $bits` # and back to octal again
                typ=0

                if [[ $(($mode & $S_ISDIR)) == $S_ISDIR ]]; then
                        typ=1;
                fi
                if [[ $(($mode & $S_ISLNK)) == $S_ISLNK ]]; then
                        typ=2;
                fi

                [[ $verbose -eq 1 ]] && echo $path >&2

                if [[ -e "$backupdir/$path" ]]; then
                        suffix=`mirror_suffix "$backupdir/$path"`
                fi

                if [[ $dump == "+" ]]; then
                        # add
                        case $typ in
                                0)      # REG
                                if [[ -e "$backupdir/$path" ]]; then
                                        mv "$backupdir/$path" "$backupdir/$path$suffix"
                                fi
                                if [[ $fsize -ne 0 ]]; then
                                        # catch
                                        dd bs=1 count=$fsize of="$backupdir/$path" 2> /dev/null
                                else 
                                        # empty
                                        touch "$backupdir/$path"
                                fi
                                chown $uid:$gid "$backupdir/$path" 2>/dev/null
                                chown_attr $uid $gid "$backupdir/$path" 
                                chmod $bits "$backupdir/$path" 
                                ftsize=$(($ftsize + $fsize))
                                ireg=$(( $ireg + 1))
                                ;;
                                1)      # DIR
                                # check for fileTYPE changes
                                if [ -f "$backupdir/$path" -o -L "$backupdir/$path" ]; then
                                        mv "$backupdir/$path" "$backupdir/$path$suffix"
                                fi

                                # size should be 0
                                [[ ! -d "$backupdir/$path" ]] && mkdir -p "$backupdir/$path"
                                chown $uid:$gid "$backupdir/$path" 2>/dev/null
                                chown_attr $uid $gid "$backupdir/$path" 

                                if [[ $UID -ne 0 && $bits -eq 0 ]]; then
                                        # if we're not read we need this
                                        # otherwise we can't access the dir
                                        _echo2 "Chmod \`$backupdir/$path' to 700"
                                        bits="700"
                                fi
                                chmod $bits "$backupdir/$path" 
                                idir=$(( $idir + 1))
                                ;;
                                2)      # LNK, target is in the content! 
                                if [[ -e "$backupdir/$path" ]]; then
                                        mv "$backupdir/$path" "$backupdir/$path$suffix"
                                fi
                                read -r -n $fsize target
                                ln -sf "$target" "$backupdir/$path" 
                                chown -h $uid:$gid "$backupdir/$path" 2>/dev/null
                                chown_attr $uid $gid "$backupdir/$path" 
                                ilnk=$(( $ilnk + 1))
                                ;;
                        esac
                else
                        # remove
                        if [[ -e "$backupdir/$path" ]]; then
                                mv "$backupdir/$path" "$backupdir/$path$suffix"
                        fi
                        irm=$(( $irm + 1))
                fi
        done 
        te=`date +%s`
        echo "** #REG FILES  : $ireg" >&2
        echo "** #DIRECTORIES: $idir" >&2
        echo "** #LINKS      : $ilnk" >&2
        echo "** #(RE)MOVED  : $irm" >&2
        echo "** SIZE        : $(($ftsize / 1024 )) KB" >&2
        echo "** STORED IN   : $backupdir" >&2
        echo "** ELAPSED     : $(($te - $ts)) s" >&2
}

while getopts ":acvhb:V" options; do
        case $options in
                a) attr=1;;
                c) remote=1;;
                b) backupdir=$OPTARG;;
                v) verbose=1;;
                V) version && exit;;
                h) usage && exit;;
                \?) _echo2 "Invalid option"; usage && exit;;
        esac
done
shift $((OPTIND - 1))

check_attr

if [ -z "$backupdir" ]; then
        backupdir="/vol/backup/`hostname`"
fi
backupdir=$backupdir/`date +%Y%m`

if [[ $remote -eq 0 ]]; then
        local_mirror
else
        remote_mirror
fi
