\documentclass[a4paper, openany]{memoir}

\newcommand{\rdup}{\textbf{rdup}}
\newcommand{\cmd}[1]{\texttt{#1}}
\newcommand{\url}[1]{\texttt{#1}}
\newcommand{\path}[1]{\texttt{#1}}
\newcommand{\flag}[1]{\textit{#1}}

%%\pagestyle{compagnion}
%% this is really cool
\pagestyle{ruled}
\chapterstyle{demo}
\begin{document}

%%\title{\rdup{} -- Easy (Personal) Backups}
%%\author{Miek Gieben\\miek@miek.nl}
%%\date{}
%%\maketitle
\section*{Abstract}
\rdup{} is small, GPL licensed utility which, together with some scripts, can
be easily used to setup and maintain backups. These can either be local
of networked backups. Encryption and compression is also supported.
The homepage of \rdup{} is located at: \\
\url{http://www.miek.nl/projects/rdup/index.html}.

Currently \rdup{} runs on Linux and FreeBSD. Because \rdup{} is
small porting it to other platforms should be relatively easy.

In this document we detail how \rdup{} works, out of which components
it consists and how to actually use it to make backups.

\tableofcontents

\chapter{Introduction to \rdup}

\section{Backups}
In an ideal world backups would not be necessary, with an un\-limited
amount of memory, non failing hard disks and some form of version
management we would always be able to retrieve past versions of our files.
\begin{quote}
\emph{Unfortunately we do need backups.}
\end{quote}
Although the act of backing up may seem trivial (just copy some files
to another medium), a number of constraints make it more difficult. 
Backups may need to be compressed or encrypted. Backups might be copied
to another host. Backups may need to be split up in such a way that
each piece will fit on a CD or DVD. Incremental backups need to be
supported. And, often neglected: recovery of backed up
files should be easy.  Also backup tools should be file system agnostic
and should be very flexible and simple in their use.

A backup tool should not re-invent the wheel.  This means that it should
try to use \cmd{ssh} for file transfers and not create a whole new
mechanism to do secure authentication. A program like \cmd{tar} can be
used to pack files, other tools can be used for encryption. 

Taking these requirements and thinking them through, the
conclusion is that the best backup program\ldots does not backup anything.
Hence: \rdup

\section{Rational Behind \rdup}
\rdup{} is an utility inspired by \cmd{rsync} and the 
\cmd{plan9}\footnote{http://plan9.escet.urjc.es/magic/man2html/4/fs} 
way of doing backups. As said, \rdup{} does not create backups. It only
prints a list of files that are changed or removed. Or all files in case
of a null dump, to standard output. 

\section{Scheme Implemented in Current Scripts}
\label{sec:scheme implemented in current scripts}
One full backup each month, incremental updates after that.

TODO


\chapter{Components of \rdup}

\rdup{} consist out of two parts, small core written in C and
a number of scripts. The current scripts are written in 
Bash version 3, but any language can be used to write them.

\section{C Core}
The main \rdup{} program is written in about 1000 lines of C code. Its
main purpose is to crawl the filesystem and to calculate which files
need to be removed and what files are new or modified. That list is then
printed to standard output.

\section{Scripts}
The current shell scripts implement the backup and restore policy, see
Section \ref{sec:scheme implemented in current scripts}.
The are quite a few of them:
\begin{description}
\item[\cmd{crypt.sh}]{-- encrypt/decrypt the files' contents,}
\item[\cmd{gzip.sh}]{-- compress/decrypt the files' contents,}
\item[\cmd{mirror.sh}]{-- store the backup to its backup directory,}
\item[\cmd{dump.sh}]{-- convenience wrapper around \cmd{rdup} and \cmd{mirror.sh}.}
\end{description}

And for restoring we have:
\begin{description}
\item[\cmd{hist.sh}]{-- inspect the backup history of a file,}
\item[\cmd{yesterday.sh}]{-- restore files from the backup,}
\item[\cmd{rorrim.sh}]{-- place to-be-restored files in a directory,}
\item[\cmd{monthday.sh}]{-- select files to restore from the backup,}
\item[\cmd{restore.sh}]{-- convenience wrapper around \cmd{rdup},
\cmd{monthday.sh} and \cmd{rorrim.sh}.} 
\end{description}

Note that \cmd{gzip.sh} and \cmd{crypt.sh} can be used for 
both backing up and restoring. See section \ref{sec:restore examples}
for some examples.

\section{How Does \rdup{} Work?}
The data \rdup{} puts out is depicted in Figure \ref{fig:rdup output}.
\begin{figure}[hbt]
\begin{verbatim}
+16877 1000 1000 11 0 
/home/miekg
+16877 1000 1000 15 0 
/home/miekg/svn
+16832 1000 1000 20 0 
/home/miekg/svn/rdup
+16832 1000 1000 26 0 
/home/miekg/svn/rdup/trunk
+33216 1000 1000 30 31 
/home/miekg/svn/rdup/trunk/apt
-33216 1000 1000 29 0 
/home/miekg/svn/rdup/trunk/nc
\end{verbatim}
\caption{A short listing of typical output from \rdup.}
\label{fig:rdup output}
\end{figure}

With this short list we can explain \rdup's output. When no
output changing options are given to \rdup{} it will output seven
columns:
\begin{enumerate}
\item{\textbf{+/-} -- whether this path should be added (+) or removed
(-),}
\item{\textbf{mode} -- the file's protection and mode bits,}
\item{\textbf{uid} -- numeric user id,}
\item{\textbf{gid} -- numeric group id,}
\item{\textbf{path size} -- the length of the path,}
\item{\textbf{file size} -- the size of the file (zero when removed),}
\item{\textbf{path} -- the full pathname.}
\end{enumerate}

\section{Remote Usage}
Figure \ref{fig:rdup -c output} shows \rdup's output with the
\textbf{-c} switch. With this switch the contents of each file is also
printed to standard output.

\begin{figure}[hbt]
\begin{verbatim}
+16877 1000 1000 11 0 
/home/miekg
+16877 1000 1000 15 0 
/home/miekg/svn
+16832 1000 1000 20 0 
/home/miekg/svn/rdup
+16832 1000 1000 26 0 
/home/miekg/svn/rdup/trunk
+33216 1000 1000 30 31 
/home/miekg/svn/rdup/trunk/apt#!/bin/bash script of 31 bytes ...
-33216 1000 1000 29 0 
/home/miekg/svn/rdup/trunk/nc
\end{verbatim}
\caption{A short listing of output from \rdup{} -c.}
\label{fig:rdup -c output}
\end{figure}

Two things are different: after the file size a newline is printed, then
the full pathname and then the file's contents.  For obvious reasons no
content is printed for files that are to be removed.

\section{Remote backups and file ownership}
When remotely storing a backup the following is a common problem.
Normally you would be making the upload as a non-root user for safety
reasons. This user has limited capabilities and can not set the ownership
of files to (for instance) root:root. This will probably lead to a
remote backup where all ownership is set to user:user. When such a
backup is restored, \rdup{} is no way of knowing what the original
ownership was. This reduces the usefulness of remote backups.

As a solution \rdup{} has a \flag{-a} flag which reads the
extended user attributes with the original ownership (uid/gid).
These attributes are set by \cmd{mirror.sh} when making the backup.

The attributes are named "r\_uid" and "r\_gid". When instructed to
do so \rdup{} will read the extended attributes. Next it will 
substitute the attributes in the uid and gid fields of its
normal output.

\chapter{Making Backups}
The most simple use of \rdup{} is to mirror files to
another partition/directory. The following example first
creates a file list using \rdup{} which is then piped to 
\cmd{mirror.sh} which processes each entry and stores the
files in 
\texttt{/vol/backup/`\$HOSTNAME`/YYYYMM}.
Note: The files \cmd{timestamp} and \cmd{FILELIST} are
both created by \rdup:
\begin{enumerate}
\item
\begin{quote}
\begin{verbatim}
rdup -N timestamp FILELIST /home | mirror.sh -b /vol/backup
\end{verbatim}
\end{quote}

\item
If you want to remotely store your backups (note the \cmd{-c} switch which makes
\rdup{} include the files' content in its output):
\begin{quote}
\begin{verbatim}
rdup -c -N timestamp FILELIST /home | \
ssh miekg@example.nl mirror.sh -c -b /vol/backup
\end{verbatim}
\end{quote}

\item
With \cmd{gzip.sh} files can be compressed:
\begin{quote}
\begin{verbatim}
rdup -c -N timestamp FILELIST /home | gzip.sh | \
ssh miekg@example.nl mirror.sh -c -b /vol/backup
\end{verbatim}
\end{quote}

\item
And with \cmd{crypt.sh} files are encrypted:
\begin{quote}
\begin{verbatim}
rdup -c -N timestamp FILELIST /home | crypt.sh secret.file | \
ssh miekg@example.nl mirror.sh -c -b /vol/backup
\end{verbatim}
\end{quote}

\item
Now with both encryption and compression and we 
send our files to remote server with bandwidth limiting; we
only allow 10Kb per second:
\begin{quote}
\begin{verbatim}
rdup -c -N timestamp FILELIST /home | gzip.sh |\
crypt.sh secret.file | cstream -t 10240 | \
ssh miekg@example.nl mirror.sh -c -b /vol/backup
\end{verbatim}
\end{quote}

\end{enumerate}

\section{Using \cmd{dump.sh}}
\cmd{dump.sh} is a wrapper script to make things more easy. If we redo
the examples from above,we get:
\begin{enumerate}
\item{\cmd{dump.sh mybackup /home}}
\item{\cmd{dump.sh -c miekg@example.nl mybackup-remote /home}}
\item{\cmd{dump.sh -z -c miekg@example.nl mybackup-remote /home}}
\item{\cmd{dump.sh -k secret.file -c miekg@example.nl mybackup-remote /home}}
\item{\cmd{dump.sh -k secret.file -z -l 10240 -c miekg@example.nl mybackup-remote /home}}
\end{enumerate}
Note that is a backup is to be compressed and encrypted (-k and -z are
both given), it will be first compressed and the encrypted.

\chapter{Restoring Backups}
With the commands \cmd{hist.sh} and \cmd{yesterday.sh} you can restore
single files from the backup. If you want to restore an entire directory
you will need the other restore scripts. Note that for restoring we
also use \cmd{rdup}.

\begin{enumerate}
\item
If you want to restore your local backup to \path{/tmp/test}.
Note the use of \path{/dev/null} for \rdup's filelist, as this is not
needed when restoring. The +0 argument to \cmd{monthday.sh} denotes
that the latest files from the backup should be selected:
\begin{quote}
\begin{verbatim}
rdup /dev/null /vol/backup/elektron/200605/home/miekg | \
monthday.sh +0 |\
rorrim.sh /tmp/test
\end{verbatim}
\end{quote}
\end{enumerate}

This also works remotely.


\section{Using \cmd{restore.sh}}

\end{document}
