#!/bin/bash
#
# Copyright (c) 2005, 2006 Miek Gieben
# See LICENSE for the license
#
# This script implement a mirroring backup scheme

. @sysconfdir@/rdup/shared.sh

backup_defines
backup_cmd_options $@

if [[ ! -z $keyfile ]]; then
        if [[ ! -z $gzip ]]; then
                echo "** Options -z and -k can not be mixed"
                exit 1
        fi
        if [[ ! -f $keyfile ]]; then
                echo "** Can not open key file"
                exit 1
        fi
fi

backup_create_top $backupdir
alg="blowfish"

declare -a path # catch spacing in the path
while read mode uid gid size path
do
        dump=${mode:0:1}        # to add or remove
        mode=${mode:1}          # st_mode bits
        bits=$(($mode & $S_MMASK)) # permission bits
        bits=`printf "%o" $bits` # and back to octal again
        typ=0
        if [[ $(($mode & $S_ISDIR)) == $S_ISDIR ]]; then
                typ=1;
        fi
        if [[ $(($mode & $S_ISLNK)) == $S_ISLNK ]]; then
                typ=2;
        fi
        
        [[ $verbose -eq 1 ]] && echo $path > /dev/fd/2

        if [[ $dump == "+" ]]; then
                # add
                case $typ in
                        0)      # reg file
                        [[ $dry -eq 0 ]] && [[ -f "$backupdir/$path" ]] && mv "$backupdir/$path" "$backupdir/$path.$suffix"
                        [[ $dry -eq 1 ]] && echo "[[ -f $backupdir/$path ]] && mv $backupdir/$path $backupdir/$path.$suffix"
                        if [[ ! -z $gzip ]]; then
                                [[ $dry -eq 0 ]] && cat "$path" | gzip -c > "$backupdir/$path"
                                [[ $dry -eq 1 ]] && echo "cat $path | gzip -c > $backupdir/$path"
                        else if [[ ! -z $keyfile ]]; then
                                [[ $dry -eq 0 ]] mcrypt -F -k "$keyfile" -a "$alg" --mode stream "$path"
                                [[ $dry -eq 1 ]] echo "mcrypt -F -k $keyfile -a $alg --mode stream $path"
                        else 
                                [[ $dry -eq 0 ]] && cat "$path" > "$backupdir/$path"
                                [[ $dry -eq 1 ]] && echo "cat $path > $backupdir/$path"
                        fi
                        [[ $dry -eq 0 ]] && chown $uid:$gid "$backupdir/$path"
                        [[ $dry -eq 1 ]] && echo "chown $uid:$gid $backupdir/$path"
                        [[ $dry -eq 0 ]] && chmod $bits "$backupdir/$path"
                        [[ $dry -eq 1 ]] && echo "chmod $bits $backupdir/$path"
                        ;;
                        1)      # directory
                        [[ $dry -eq 0 ]] && [[ ! -d "$backupdir/$path" ]] && mkdir -p "$backupdir/$path"
                        [[ $dry -eq 1 ]] && echo "[[ ! -d $backupdir/$path ]] && mkdir -p $backupdir/$path"
                        [[ $dry -eq 0 ]] && chown $uid:$gid "$backupdir/$path"
                        [[ $dry -eq 1 ]] && echo "chown $uid:$gid $backupdir/$path"
                        [[ $dry -eq 0 ]] && chmod $bits "$backupdir/$path"
                        [[ $dry -eq 1 ]] && echo "chmod $bits $backupdir/$path"
                        ;;
                        2)      # link
                        [[ $dry -eq 0 ]] && [[ -L "$backupdir/$path" ]] && mv "$backupdir/$path" "$backupdir/$path.$suffix"
                        [[ $dry -eq 1 ]] && echo "[[ -L $backupdir/$path ]] && mv $backupdir/$path $backupdir/$path.$suffix"
                        [[ $dry -eq 0 ]] && cp -a "$path" "$backupdir/$path"
                        [[ $dry -eq 1 ]] && echo "cp -a $path $backupdir/$path"
                        [[ $dry -eq 0 ]] && chown $uid:$gid "$backupdir/$path"
                        [[ $dry -eq 1 ]] && echo "chown $uid:$gid $backupdir/$path"
                        [[ $dry -eq 0 ]] && chmod $bits "$backupdir/$path"
                        [[ $dry -eq 1 ]] && echo "chmod $bits $backupdir/$path"
                        ;;
                esac
        else
                # remove
                [[ $dry -eq 0 ]] && mv "$backupdir/$path" "$backupdir/$path.$suffix"
                [[ $dry -eq 1 ]] && echo "mv $backupdir/$path $backupdir/$path.$suffix"
        fi
done 
backup_successfull $backupdir
